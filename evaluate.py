# -*- coding: utf-8 -*-
"""
    evaluate provides functions to evluate the psychometric function fit
    returned by psignifit.
"""
import numpy as np
from scipy.stats import beta, norm, t
import warnings
import matplotlib.pyplot as plt

from psignifit import psignifit
from psigniplot import plotPsych, plotMarginal
from utils import my_norminv, my_t1icdf

def getSlope(result, stimLevel):
    """ 
    function slope = getSlope(result, pCorrect, unscaled, stimLevel)
    This function finds the slope of the psychometric function at a given
    performance level in percent correct. 
    
    result is a result dictionary from psignifit
    
    stimLevel is the stimuluslevel at where to evaluate the slope
    
    This function cannot provide credible intervals. 
    """

    if 'Fit' in result.keys():
        theta0 = result['Fit']
    else:
        raise ValueError('Result needs to contain a resulting fit generated by psignifit')
        


    #calculate point estimate -> transform only the fit

    alpha = result['options']['widthalpha']
    if 'threshPC' in result['options'].keys():
        PC    = result['options']['threshPC']
    else:
        PC = 0.5
    
    ''' find the (normalized) stimulus level, where the given percent correct is
    reached and evaluate slope there'''
    sigName = result['options']['sigmoidName'] 
    
    if sigName in ['norm', 'gauss']:
        C         = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        normalizedStimLevel = (stimLevel-theta0[0])/theta0[1]*C
        
        slopeNormalized = norm.pdf(normalizedStimLevel)
        slope = slopeNormalized *C/theta0[1]
    elif sigName == 'logistic':
        C = 2 * np.log(1/alpha - 1) / theta0[1]
        d = np.log(1/PC-1)
        slope = C*np.exp(-C*(stimLevel-theta0[0])+d)/(1+np.exp(-C*(stimLevel-theta0[0])+d))**2
    elif sigName ==  'gumbel':
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        stimLevel = C/theta0[1]*(stimLevel-theta0[0])+np.log(-np.log(1-PC))
        slope = C/theta0[1]*np.exp(-np.exp(stimLevel))*np.exp(stimLevel)
    elif sigName == 'rgumbel':                  #reversed gumbel
        C      = np.log(-np.log(1-alpha)) - np.log(-np.log(alpha))
        stimLevel = C/theta0[1]*(stimLevel-theta0[0])+np.log(-np.log(PC))
        slope = -C/theta0[1]*np.exp(-np.exp(stimLevel))*np.exp(stimLevel)
    elif sigName == 'logn':
        C      = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        normalizedStimLevel = (np.log(stimLevel)-theta0[0])/theta0[1]
        slopeNormalized = norm.pdf(normalizedStimLevel)
        slope = slopeNormalized *C/theta0[1]/stimLevel 
    elif sigName in ['Weibull','weibull']:
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        stimLevelNormalized = C/theta0[1]*(np.log(stimLevel)-theta0[0])+np.log(-np.log(1-PC))
        slope = C/theta0[1]*np.exp(-np.exp(stimLevelNormalized))*np.exp(stimLevelNormalized)
        slope = slope/stimLevel
    elif sigName in ['tdist','student','heavytail']:
        # student T distribution with 1 df --> heavy tail distribution
        C      = (my_t1icdf(1-alpha) - my_t1icdf(alpha))
        stimLevel = (stimLevel-theta0[0])/theta0[1]*C+my_t1icdf(PC)
        slope = C/theta0[1]*t.pdf(stimLevel,df=1)
    else:
        raise ValueError('unknown sigmoid function')


    slope   = (1-theta0[2]-theta0[3])*slope
    
    return slope
    

def getSlopePC(result, pCorrect, unscaled = False):
    
    if 'Fit' in result.keys():
        theta0 = result['Fit']
    else:
        raise ValueError('Result needs to contain a resulting fit generated by psignifit')
        


    #calculate point estimate -> transform only the fit

    alpha = result['options']['widthalpha']
    if 'threshPC' in result['options'].keys():
        PC    = result['options']['threshPC']
    else:
        PC = 0.5

    if unscaled:
        assert ((pCorrect > 0) & (pCorrect < 1)), 'pCorrect must be in ]0,1[ '
        pCorrectUnscaled = pCorrect
    else:
        assert ((pCorrect > theta0[3]) & (pCorrect < (1-theta0[2]))), 'pCorrect must lay btw {:.2f} and {:.2f}'.format(theta0[3], (1-theta0[2]))
        pCorrectUnscaled = (pCorrect-theta0[3])/(1-theta0[2] - theta0[3])
        
    ''' find the (normalized) stimulus level, where the given percent correct is
    reached and evaluate slope there'''
    sigName = result['options']['sigmoidName'] 
    
    if sigName in ['norm', 'gauss']:
        C         = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        normalizedStimLevel = my_norminv(pCorrectUnscaled,0,1)
        slopeNormalized = norm.pdf(normalizedStimLevel)
        slope = slopeNormalized *C/theta0[1]
    elif sigName == 'logistic':
        stimLevel = theta0[0] - theta0[1]*np.log((1/pCorrectUnscaled-1)-np.log(1/PC-1))/2/np.log(1/alpha-1)
        C = 2 * np.log(1/alpha - 1) / theta0[1]
        d = np.log(1/PC-1)
        slope = C*np.exp(-C*(stimLevel-theta0[0])+d)/(1+np.exp(-C*(stimLevel-theta0[0])+d))**2
    elif sigName ==  'gumbel':
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        stimLevel = np.log(-np.log(1-pCorrectUnscaled))
        slope = C/theta0[1]*np.exp(-np.exp(stimLevel))*np.exp(stimLevel)
    elif sigName == 'rgumbel':                  #reversed gumbel
        C      = np.log(-np.log(1-alpha)) - np.log(-np.log(alpha))
        stimLevel = np.log(-np.log(pCorrectUnscaled))
        slope = -C/theta0[1]*np.exp(-np.exp(stimLevel))*np.exp(stimLevel)       
    elif sigName == 'logn':
        C      = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        stimLevel = np.exp(my_norminv(pCorrectUnscaled, theta0[0]-my_norminv(PC,0,theta0[1]/C), theta0[1] / C))
        normalizedStimLevel = my_norminv(pCorrectUnscaled, 0,1)        
        slopeNormalized = norm.pdf(normalizedStimLevel)
        slope = slopeNormalized *C/theta0[1]/stimLevel 
    elif sigName in ['Weibull','weibull']:
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        stimLevel = np.exp(theta0[0]+theta0[1]/C*(np.log(-np.log(1-pCorrectUnscaled))-np.log(-np.log(1-PC))))
        stimLevelNormalized = np.log(-np.log(1-pCorrectUnscaled))
        slope = C/theta0[1]*np.exp(-np.exp(stimLevelNormalized))*np.exp(stimLevelNormalized)
        slope = slope/stimLevel
    elif sigName in ['tdist','student','heavytail']:
        # student T distribution with 1 df --> heavy tail distribution
        C      = (my_t1icdf(1-alpha) - my_t1icdf(alpha))
        stimLevel = my_t1icdf(pCorrectUnscaled)
        slope = C/theta0[1]*t.pdf(stimLevel,df=1)
    else:
        raise ValueError('unknown sigmoid function')


    slope   = (1-theta0[2]-theta0[3])*slope
    
    return slope
    
    
def getThreshold(result,pCorrect, unscaled=False):
    """
    function [threshold,CI] = getThreshold(result, pCorrect,unscaled)
     this function finds a threshold value for a given fit for different
     percent correct cutoffs
    
     result is a result dict from psignifit
    
     pCorrect is the percent correct at the threshold you want to calculate
    
     unscaled is whether the percent correct you provide are for the unscaled
     sigmoid or for the one scaled by lambda and gamma. By default this
     function returns the one for the scaled sigmoid.
    
     The CIs you may obtain from this are calculated based on the confidence
     intervals only, e.g. with the shallowest and the steepest psychometric
     function and may thus broaden if you move away from the standard
     threshold of unscaled sigmoid = .5 /= options['threshPC']
    
     For the sigmoids in logspace this also returns values in the linear
     stimulus level domain.
    
    
     For a more accurate inference use the changed level of percent correct
     directly to define the threshold in the inference by setting
     options['threshPC'] and adjusting the priors.
    """

    if 'Fit' in result.keys():
        theta0 = result['Fit']
    else:
        raise ValueError('Result needs to contain a resulting fit generated by psignifit.')
    if 'conf_Intervals' in result.keys():
        CIs = result['conf_Intervals']
    else:
        raise ValueError('Result needs to contain confidence intervals for the fitted parameter.')
    

    if unscaled: # set asymptotes to 0 for everything.
        theta0[2]  = 0
        theta0[3]  = 0
        CIs[2:5,:] = 0
        

    assert((np.array(pCorrect)>theta0[3]) & (np.array(pCorrect)<(1-theta0[2])), 'The threshold percent correct is not reached by the sigmoid!')

    """  calculate point estimate threshold -> transform only result['Fit'] """

    pCorrectUnscaled = (pCorrect-theta0[3])/(1-theta0[2]-theta0[3])
    alpha = result['options']['widthalpha']
    if  'threshPC' in result['options'].keys():
        PC    = result['options']['threshPC']
    else :
        PC = 0.5

    sigName = result['options']['sigmoidName']
    if sigName in ['norm', 'gauss']:
        C         = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        threshold = my_norminv(pCorrectUnscaled, theta0[0]-my_norminv(PC,0,theta0[1]/C), theta0[1] / C)
    elif sigName ==  'logistic':
        threshold = theta0[0]-theta0[1]*(np.log(1/pCorrectUnscaled-1)-np.log(1/PC-1))/2/np.log(1/alpha-1)
    elif sigName == 'gumbel' :
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        threshold = theta0[0] + (np.log(-np.log(1-pCorrectUnscaled))-np.log(-np.log(1-PC)))*theta0[1]/C
    elif sigName == 'rgumbel':
        C      = np.log(-np.log(1-alpha)) - np.log(-np.log(alpha))
        threshold = theta0[0] + (log(-log(pCorrectUnscaled))-log(-log(PC)))*theta0[1]/C
    elif sigName == 'logn':
        C      = my_norminv(1-alpha,0,1) - my_norminv(alpha,0,1)
        threshold = np.exp(my_norminv(pCorrectUnscaled, theta0[0]-my_norminv(PC,0,theta0[1]/C), theta0[1] / C))
    elif sigName in ['Weibull','weibull']:
        C      = np.log(-np.log(alpha)) - np.log(-np.log(1-alpha))
        threshold = np.exp(theta0[0]+theta0[1]/C*(np.log(-np.log(1-pCorrectUnscaled))-np.log(-np.log(1-PC))))
    elif sigName in ['tdist','student','heavytail']:
        C      = (my_t1icdf(1-alpha) - my_t1icdf(alpha))
        threshold = (my_t1icdf(pCorrectUnscaled)-my_t1icdf(PC))*theta0[1] / C + theta0[0]
    else:
        raise ValueError('unknown sigmoid function')

    """ calculate CI -> worst case in parameter confidence intervals """
    
    warnings.warn('The CIs computed by this method are only upper bounds. For more accurate inference change threshPC in the options.')
    CI = np.zeros([len(result['options']['confP']),2])
    for iConfP in range(0,len(result['options']['confP'])):
        if pCorrectUnscaled > PC:
            thetaMin = [CIs[0,0,iConfP],CIs[1,0,iConfP],CIs[2,0,iConfP],CIs[3,0,iConfP],0]
            thetaMax = [CIs[0,1,iConfP],CIs[1,1,iConfP],CIs[2,1,iConfP],CIs[3,1,iConfP],0]
        else:
            thetaMin = [CIs[0,0,iConfP],CIs[1,1,iConfP],CIs[2,0,iConfP],CIs[3,1,iConfP],0]
            thetaMax = [CIs[0,1,iConfP],CIs[1,0,iConfP],CIs[2,1,iConfP],CIs[3,0,iConfP],0]
        pCorrMin = (pCorrect-thetaMin[3])/(1-thetaMin[2]-thetaMin[3])
        pCorrMax = (pCorrect-thetaMax[3])/(1-thetaMax[2]-thetaMax[3])
        if sigName in ['norm', 'gauss']:
            CI[iConfP,0]     = my_norminv(pCorrMin, thetaMin[0]-my_norminv(PC,0,thetaMin[1]/C), thetaMin[1] / C)
            CI[iConfP,1]     = my_norminv(pCorrMax, thetaMax[0]-my_norminv(PC,0,thetaMax[1]/C), thetaMax[1] / C)
        elif sigName =='logistic':
            CI[iConfP,0]     = thetaMin[0]-thetaMin[1]*(np.log(1/pCorrMin-1)-np.log(1/PC-1))/2/np.log(1/alpha-1)
            CI[iConfP,1]     = thetaMax[0]-thetaMax[1]*(np.log(1/pCorrMax-1)-np.log(1/PC-1))/2/np.log(1/alpha-1)
        elif sigName == 'gumbel':
            CI[iConfP,0] = thetaMin[0] + (np.log(-np.log(1-pCorrMin))-np.log(-np.log(1-PC)))*thetaMin[1]/C
            CI[iConfP,1] = thetaMax[0] + (np.log(-np.log(1-pCorrMax))-np.log(-np.log(1-PC)))*thetaMax[1]/C
        elif sigName == 'rgumbel':
            CI[iConfP,0] = thetaMin[0] + (np.log(-np.log(pCorrMin))-np.log(-np.log(PC)))*thetaMin[1]/C
            CI[iConfP,1] = thetaMax[0] + (np.log(-np.log(pCorrMax))-np.log(-np.log(PC)))*thetaMax[1]/C
        elif sigName =='logn':
            CI[iConfP,0] = np.exp(my_norminv(pCorrMin, thetaMin[0]-my_norminv(PC,0,thetaMin[1]/C), thetaMin[1]/ C))
            CI[iConfP,1] = np.exp(my_norminv(pCorrMax, thetaMax[0]-my_norminv(PC,0,thetaMax[1]/C), thetaMax[1] / C))
        elif sigName in ['Weibull','weibull']:
            CI[iConfP,0] = np.exp(thetaMin[0]+thetaMin[1]/C*(np.log(-np.log(1-pCorrMin))-np.log(-np.log(1-PC))))
            CI[iConfP,1] = np.exp(thetaMax[0]+thetaMax[1]/C*(np.log(-np.log(1-pCorrMax))-np.log(-np.log(1-PC))))
        elif sigName in ['tdist','student','heavytail']:
            CI[iConfP,0] = (my_t1icdf(pCorrMin)-my_t1icdf(PC))*thetaMin[1] / C + thetaMin[0]
            CI[iConfP,1] = (my_t1icdf(pCorrMax)-my_t1icdf(PC))*thetaMax[1] / C + thetaMax[0]
        else:
             raise ValueError('unknown sigmoid function')
        
        if (pCorrMin>1) | (pCorrMin<0):
            CI[iConfP,0] = np.nan
        
        if (pCorrMax>1) | (pCorrMax<0):
            CI[iConfP,1] = np.nan
            
    return (threshold,CI)
    

def biasAna(data1, data2,options):
    """ function biasAna(data1,data2,options)
 runs a short analysis to see whether two 2AFC datasets have a bias and
 whether it can be explained with a "finger bias"-> a bias in guessing """


    options['priors'] = []
    options['borders'] = np.empty([5,2])
    options['borders'][:] = np.nan
    options['expType'] = 'YesNo'

    options['priors'][3] = lambda x: scipy.stats.beta.pdf(x,2,2)    
    options['borders'][2,:] = np.array([0,.1])
    options['borders'][3,:] = np.array([.11,.89])
    options['fixedPars'] = np.ones([5,1])*np.nan
    options['fixedPars'][4] = 0
    options['stepN']   = np.array([40,40,40,40,1])
    options['mbStepN'] = np.array([30,30,20,20,1])

    resAll = psignifit(np.append(data1, data2, axis=0),options)
    res1 = psignifit(data1,options)
    res2 = psignifit(data2,options)

    plt.figure(figsize=[400,1200])
    plt.gca().set_position([0.15,4.35/6,0.75,1.5/6])

    plotPsych(resAll)
    plt.hold(True)
    
    plotPsych(res1, lineColor= [1,0,0], dataColor = [1,0,0] )
    plotPsych(res2,lineColor= [0,0,1], dataColor = [0,0,1])
    plt.ylim([0,1])

    plt.gca().set_position([0.15,3.35/6,0.75,0.5/6])

    plotMarginal(resAll,dim = 0,prior = False, CIpatch = False, lineColor = [0,0,0])
    plt.hold(True)
    
    plotMarginal(res1,dim = 0,lineColor = [1,0,0])
    plotMarginal(res2,dim = 0,lineColor=[0,0,1])
    plt.gca().set_xlim(auto=True)
    plt.gca().set_ylim(auto = True)


    plt.gca().set_position([0.15,2.35/6,0.75,0.5/6])
    plotMarginal(resAll,dim = 1,prior = False, CIpatch=False, lineColor = [0,0,0])
    plt.hold(True)

    plotMarginal(res1,dim = 1,lineColor=[1,0,0])
    plotMarginal(res2,dim = 1,lineColor=[0,0,1])
    plt.gca().set_xlim(auto=True)
    plt.gca().set_ylim(auto=True)

    plt.gca().set_position([0.15,1.35/6,0.75,0.5/6])

    plotMarginal(resAll,dim = 2, prior = False, CIpatch = False, lineColor = [0,0,0])
    plt.hold(True)
    
    plotMarginal(res1,dim = 2, lineColor=[1,0,0])
    plotMarginal(res2,dim=2, lineColor=[0,0,1])
    plt.gca().set_xlim(auto=True)
    plt.gca().set_ylim(auto=True)
    
    plt.gca().set_position([0.15,0.35/6,0.75,0.5/6])

    plotMarginal(resAll,dim = 3, prior = False, CIpatch = False, lineColor = [0,0,0])
    plt.hold(True)
    
    plotMarginal(res1,dim = 3, lineColor=[1,0,0])
    plotMarginal(res2,dim = 3, lineColor=[0,0,1])
    plt.gca().set_xlim([0,1])
    plt.gca().set_ylim(auto=True)
    
    plt.show()

    
    

